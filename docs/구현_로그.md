# WSI 타일 서버 + OpenSeaDragon 연동 구현 로그

이 문서는 **원본 WSI → 타일 서빙 → 뷰어** PoC를 진행하면서 한 작업을 단계별로 기록한 로그다.  
워크플로우·도메인 지식·서버 구축 학습을 위해, 모를 수 있는 개념은 설명을 함께 적었다.

---

##### 5. 로그 목차 (작업 순서)

- [1단계: 타일 서버 구조 및 의존성](#6-1단계-타일-서버-구조-및-의존성)
- [2단계: 타일 서버 API 구현](#7-2단계-타일-서버-api-구현)
- [3단계: 프론트엔드 – OpenSeaDragon, API 연동](#8-3단계-프론트엔드--openseadragon-api-연동)
- [4단계: OSD–deck.gl 동기화 및 App UI](#9-4단계-osddeckgl-동기화-및-app-ui)
- [5단계: 문서 및 정리](#10-5단계-문서-및-정리)
- [타일 서버 구축 이후 추가 변경 사항](#13-타일-서버-구축-이후-추가-변경-사항)
- [타일 요청 계산과 레벨 크기 (OSD vs OpenSlide)](#14-타일-요청-계산과-레벨-크기-osd-vs-openslide-vs-우리-코드)

---

##### 6. 1단계: 타일 서버 구조 및 의존성

**목표:** 원본 WSI 파일을 “타일”로 잘라서 웹에서 요청할 수 있게 해 주는 서버의 뼈대와 의존성을 만든다.

**추가된 파일 구조**

```
tile-server/
  app/
    __init__.py
    main.py         # FastAPI 앱, CORS, 라우터 등록
    slides.py       # /api/slides 관련 라우트
    tile_service.py # OpenSlide로 WSI 읽기, 타일 생성 로직
  requirements.txt # fastapi, uvicorn, openslide-python, Pillow
  README.md        # 설치·실행·API 요약
```

**의존성 설명**

- **FastAPI:** Python 웹 프레임워크. 경로(엔드포인트)별로 함수를 붙이고, 자동으로 JSON 직렬화·검증을 해 준다. Flask보다 타입 힌트·비동기 지원이 강하다.
- **uvicorn:** ASGI 서버. FastAPI 앱을 실제 HTTP 서버로 실행한다. `--reload` 옵션으로 코드 수정 시 자동 재시작.
- **openslide-python:** OpenSlide C 라이브러리의 Python 바인딩. WSI 파일을 열고, “특정 레벨·특정 영역”만 읽는 `read_region(level, (x,y), width, height)` 같은 API를 제공한다. **시스템에 OpenSlide C 라이브러리가 먼저 설치되어 있어야** 한다 (Windows 설치 프로그램, macOS `brew install openslide`, Linux 패키지).
- **Pillow:** 이미지 인코딩(영역 픽셀 → JPEG/PNG 바이트)에 사용.

**CORS란**

- 브라우저는 “다른 출처(프로토콜·호스트·포트가 다른 URL)”로 요청을 보낼 수 있지만, **서버가 “이 출처에서 온 요청을 허용한다”는 헤더를 보내지 않으면** 응답 내용을 JavaScript에서 읽지 못하게 막는다. 이를 Same-Origin Policy라 하고, 이를 완화하기 위해 서버가 보내는 헤더가 CORS(Cross-Origin Resource Sharing)다.
- 여기서는 프론트가 `http://localhost:5173`, 타일 서버가 `http://localhost:8000`이므로 “다른 출처”가 된다. 그래서 타일 서버에서 `allow_origins=["http://localhost:5173"]` 같은 CORS 설정을 해 두었다.

---

##### 7. 2단계: 타일 서버 API 구현

**목표:** 슬라이드 목록 조회, 슬라이드 메타정보 조회, 타일 이미지 반환 API를 구현한다.

**API 요약**

| 메서드 | 경로 | 설명 | 응답 |
|--------|------|------|------|
| GET | `/api/slides` | WSI_DIR 내 지원 확장자 파일 목록 | `{ items: [{ id, name }] }` |
| GET | `/api/slides/{slide_id}/info` | 해당 슬라이드 메타정보 (level 0 크기, 레벨 수, 타일 크기) | `{ width, height, levelCount, tileSize, levelDimensions?, levelDownsamples? }` (levelDimensions: 각 레벨 [w,h], levelDownsamples: 다운샘플 배율 배열) |
| GET | `/api/slides/{slide_id}/tiles/{level}/{x}_{y}.jpg` | 지정 level·(x,y) 타일 이미지 | JPEG 바이트 |

**도메인 개념**

- **WSI(Whole Slide Image):** 현미경 슬라이드를 스캔한 매우 큰 이미지. 한 장이 수만~수십만 픽셀이라 통째로 메모리에 올리지 않고, “해상도 레벨”과 “영역(region)” 단위로 읽는다.
- **OpenSlide level:** level 0 = 최고 해상도(원본), level 1 = 1/2, level 2 = 1/4 … 처럼 피라미드 구조. `level_dimensions[i]`로 해당 레벨의 (width, height)를 얻는다.
- **타일:** 클라이언트(OpenSeaDragon)가 “이미지의 한 조각”을 요청할 때의 단위. 여기서는 256×256 픽셀. `read_region(level, (x*256, y*256), 256, 256)`로 해당 영역만 읽어 JPEG로 인코딩해 반환한다.
- **slide_id:** 파일명에서 확장자를 뺀 값. 서버는 `WSI_DIR` 아래에서 `{slide_id}.ndpi`, `{slide_id}.svs` 등 지원 확장자를 순서대로 찾아 첫 번째로 존재하는 파일을 연다.

**에러 처리**

- 슬라이드를 찾을 수 없으면 404. OpenSlide로 파일을 열거나 타일을 읽다가 예외가 나면 500과 메시지를 반환한다.

---

##### 8. 3단계: 프론트엔드 – OpenSeaDragon, API 연동

**목표:** 타일 서버 URL 설정, 슬라이드 목록·슬라이드 정보를 불러오는 API 함수와 OpenSeaDragon 뷰어 컴포넌트를 추가한다.

**추가·변경된 파일**

```
src/
  api/
    config.ts           # TILE_SERVER_BASE_URL (VITE_TILE_SERVER_URL)
    fetchSlides.ts      # GET /api/slides → SlideItem[]
    fetchSlideInfo.ts   # GET /api/slides/{id}/info → SlideInfo
  components/
    WSIViewer.tsx       # OSD + deck.gl 오버레이, 뷰포트 동기화
  types/
    openseadragon.d.ts  # openseadragon 모듈 타입 선언
package.json            # openseadragon 의존성 추가
```

**환경 변수 (Vite)**

- Vite는 `VITE_` 접두사가 붙은 환경 변수만 클라이언트에 노출한다. `import.meta.env.VITE_TILE_SERVER_URL`로 읽으며, 빌드 시점에 문자열로 치환된다. 따라서 값을 바꾼 뒤에는 `npm run dev`를 다시 실행해야 한다.

**OpenSeaDragon 타일 소스**

- OSD는 “타일 소스”를 받아서, 줌 레벨과 (x, y) 타일 인덱스마다 `getTileUrl(level, x, y)`를 호출해 이미지 URL을 얻는다. 여기서는 그 URL이 우리 타일 서버의 `/api/slides/{id}/tiles/{level}/{x}_{y}.jpg`가 되도록 했다.
- **레벨 방향:** OpenSeaDragon은 level 0을 “가장 낮은 해상도(이미지 전체가 한 타일처럼)”로 쓰고, level이 커질수록 해상도가 높아진다. OpenSlide는 level 0이 최고 해상도이므로, 클라이언트에서 `serverLevel = levelCount - 1 - osdLevel`로 변환해 서버에 넘긴다.

---

##### 9. 4단계: OSD–deck.gl 동기화 및 App UI

**목표:** OpenSeaDragon 뷰어와 deck.gl 오버레이가 같은 “보이는 영역”을 가리키도록 뷰포트를 동기화하고, App에서 슬라이드 선택 UI와 뷰어 전환을 넣는다.

**뷰포트 동기화**

- OSD는 줌·팬 시 `viewport`가 바뀐다. `viewport.getCenter()`는 “지금 화면 중심이 이미지(level 0)의 어느 점인지”를 픽셀 좌표로 준다. `viewport.getZoom()`은 “한 이미지 픽셀당 화면 픽셀 수”에 해당하는 배율이다.
- deck.gl은 OrthographicView를 쓰고, `viewState.target`이 “화면 중심에 올 세계 좌표”, `viewState.zoom`이 “1 세계 단위당 픽셀 수”를 제어한다. 여기서 세계 좌표 = 슬라이드 level 0 픽셀과 동일하게 맞췄다.
- OSD의 `addHandler('animation', ...)`, `addHandler('zoom', ...)`, `addHandler('pan', ...)`에서 `getCenter()`, `getZoom()`을 읽어 `setViewState`로 deck.gl의 target·zoom을 갱신한다. 그러면 마커·tumor area(level 0 좌표)가 슬라이드 위에 맞춰 겹쳐 보인다.
- deck.gl 쪽은 `controller: false`로 두어, 조작은 전부 OSD만 하게 했다. 오버레이 레이어는 `pointerEvents: 'none'`으로 두고, 필요하면 나중에 특정 레이어만 클릭 가능하게 바꿀 수 있다.

**App 흐름**

- `useQuery(['slides'], fetchSlides)`로 마운트 시 슬라이드 목록을 요청한다. 타일 서버가 꺼져 있으면 실패하므로 `retry: false`로 두어, 실패 시 빈 목록으로 두고 “단일 이미지 모드”만 쓸 수 있게 했다.
- `selectedSlideId` 상태로 드롭다운에서 선택한 슬라이드를 저장한다. 선택 시 `useQuery(['slideInfo', selectedSlideId], () => fetchSlideInfo(selectedSlideId))`로 메타정보를 가져온다.
- `selectedSlideId`가 있고 `slideInfo`가 있으면 `WSIViewer`를, 아니면 기존 `ImageMarkerViewer`를 렌더한다. “데이터 불러오기”는 마커·tumor area만 다시 불러오는 동작은 그대로다.

**파일 구조 (이번 단계 반영)**

```
src/
  App.tsx              # selectedSlideId, slides 쿼리, slideInfo 쿼리, 드롭다운, WSIViewer/ImageMarkerViewer 분기
  components/
    WSIViewer.tsx      # OSD 초기화, getTileUrl, syncViewport, deck.gl layers
```

---

##### 10. 5단계: 문서 및 정리

**한 작업**

- 루트 `README.md`: 타일 서버 설치·실행·`WSI_DIR` 설정, 프론트에서 `VITE_TILE_SERVER_URL` 사용 안내 추가.
- `.env.example`: `VITE_TILE_SERVER_URL` 예시 추가.
- `tile-server/README.md`: 이미 1·2단계에서 API 요약과 실행 방법을 적어 두었음.

**실행 순서 정리**

1. (WSI 사용 시) OpenSlide C 라이브러리 설치 후, `tile-server`에서 `WSI_DIR` 지정하고 `uvicorn app.main:app --reload --port 8000` 실행.
2. 프로젝트 루트에서 `npm install` → `npm run dev`. 필요 시 `.env`에 `VITE_TILE_SERVER_URL` 설정.
3. 브라우저에서 슬라이드 선택 시 타일 서버에서 타일을 받아 OSD로 표시되고, “데이터 불러오기”로 마커·tumor area를 불러오면 deck.gl 오버레이로 겹쳐진다.

---

##### 11. 전체 파일 구조 (구현 후)

```
tile-server/
  app/
    __init__.py
    main.py
    slides.py
    tile_service.py
  requirements.txt
  README.md

src/
  api/
    config.ts
    fetchMarkers.ts
    fetchSlideInfo.ts
    fetchSlides.ts
    fetchTumorAreas.ts
  components/
    ImageMarkerViewer.tsx
    WSIViewer.tsx
  stores/
    viewerStore.ts
  types/
    marker.ts
    openseadragon.d.ts
  App.tsx
  main.tsx
  ...
```

---

##### 12. API 한눈에 보기

**타일 서버 (기본 base: http://localhost:8000)**

| 메서드 | 경로 | 용도 |
|--------|------|------|
| GET | /health | 서버 생존 확인 |
| GET | /api/slides | 슬라이드 목록 |
| GET | /api/slides/{slide_id}/info | 슬라이드 메타정보 |
| GET | /api/slides/{slide_id}/tiles/{level}/{x}_{y}.jpg | 타일 이미지 |

**프론트에서 쓰는 타일 서버 호출**

- `fetchSlides()` → `GET /api/slides` → `SlideItem[]`
- `fetchSlideInfo(slideId)` → `GET /api/slides/{id}/info` → `SlideInfo`
- OpenSeaDragon이 `getTileUrl(level, x, y)`로 생성한 URL → `GET /api/slides/{id}/tiles/{serverLevel}/{x}_{y}.jpg` (serverLevel = levelCount - 1 - level)

---

##### 13. 타일 서버 구축 이후 추가 변경 사항

이 섹션은 5단계(문서 및 정리) 이후에 진행한 변경들을 기록한다. **줌 기준점(zoom pivot) 문제는 미해결**이며, 내일 검토용으로 정리해 둔다.

**13.1 뷰포트 동기화 방식 변경 (OSD → deck.gl)**

- **목적:** 줌/팬 시 deck.gl 오버레이가 OSD와 같은 위치·배율을 보이도록.
- **기존:** `getCenter()`로 뷰포트 중심을 구한 뒤 `viewportToImageCoordinates(center.x, center.y)`로 이미지 좌표 변환, `getZoom()`을 그대로 log2하여 deck.gl `viewState.target`, `viewState.zoom`에 반영.
- **변경:**
  - **중심 계산:** `getCenter()` 대신 `getBounds(true)`로 현재 보이는 영역(뷰포트 사각형)을 구하고, `viewportToImageRectangle(bounds.x, bounds.y, bounds.width, bounds.height)`로 이미지 좌표 사각형으로 변환한 뒤, 그 사각형의 중심 `(x + width/2, y + height/2)`를 `viewState.target`으로 사용.
  - **현재값 사용:** `getBounds(true)`, `getZoom(true)`로 애니메이션 중인 **현재** 위치·줌을 사용 (target이 아닌 current).
  - **줌 변환:** OSD의 viewport zoom을 `viewportToImageZoom(viewportZoom)`으로 이미지 줌으로 바꾼 뒤 `Math.log2(Math.max(0.001, imageZoom))`을 deck.gl zoom으로 사용.
  - **open 시:** `open` 이벤트에서 `syncViewport()`를 한 번 더 호출해 초기 뷰와 오버레이를 맞춤.
- **관련 파일:** `src/components/WSIViewer.tsx` (syncViewport, viewerRef 타입에 getBounds, viewportToImageRectangle, viewportToImageZoom 추가).

**13.2 상단에 배율·중심 좌표 표시**

- **목적:** 현재 이미지 배율과 뷰 중심(이미지 픽셀 좌표)을 확인할 수 있도록.
- **구현:** WSIViewer 상단에 반투명 바를 두고 `배율: {imageZoom.toFixed(2)}×`, `중심: ({centerX}, {centerY})` 표시. `imageZoom = 2^viewState.zoom`, 중심은 `viewState.target[0/1]`를 반올림.
- **관련 파일:** `src/components/WSIViewer.tsx`.

**13.3 줌 기준점(zoom pivot) 문제 및 시도한 수정**

- **증상:** 줌 시 “화면 정중앙 기준으로 확대”되어야 하는데, 실제로는 **다른 위치**(좌하단 → 좌상단 → 우상단 등)를 기준으로 줌되는 것처럼 보임.
- **시도 1 – zoomToRefPoint: false**
  - OpenSeadragon 옵션 `gestureSettingsMouse/Touch/Pen/Unknown`에 `zoomToRefPoint: false` 설정. 문서상 “캔버스 중심” 기준 줌이 되어야 하나, 실제로는 **좌상단** 기준으로 줌되는 것처럼 동작.
- **시도 2 – 스크롤 줌을 뷰포트 중심으로 직접 처리**
  - `gestureSettings`의 zoomToRefPoint 제거.
  - `canvas-scroll` 이벤트 핸들러 추가: `e.preventDefaultAction = true`로 OSD 기본 줌 차단 후, `viewer.viewport.getCenter(true)`로 현재 뷰포트 중심을 구하고 `viewer.viewport.zoomBy(factor, center)`로 해당 점을 기준으로 줌 실행.
  - 의도: 항상 “화면 정중앙”을 기준으로 줌. 적용 후 사용자 피드백으로 **우상단** 기준으로 줌된다고 함 → **미해결**.
- **가능한 원인 (검토용):**
  - OSD `pointFromPixel` / `getCenter`와 실제 그려지는 타일 좌표계 불일치 (커스텀 타일 소스·오버레이 구조 영향).
  - deck.gl 오버레이가 `pointerEvents: 'none'`이어도 OSD 컨테이너와 이벤트/좌표계가 어긋날 수 있음.
  - 뷰포트 “현재 중심”이 보정(제스처·애니메이션) 과정에서 잘못 계산되거나, 컨테이너 크기/마진 등으로 기준이 틀어짐.
- **관련 파일:** `src/components/WSIViewer.tsx` (canvas-scroll 핸들러, OpenSeadragon 옵션).

**13.4 레벨별 타일 위치 불일치 대응 (levelDimensions)**

- **증상:** “레벨이 달라질 때 타일이 서로 위치가 매칭이 제대로 안 된다.”
- **원인 가설:** OpenSeaDragon은 레벨 0 크기를 `(width/2^maxLevel, height/2^maxLevel)`로 가정하는데, OpenSlide 실제 레벨 크기는 스캐너에 따라 정확한 2배수가 아닐 수 있어, 레벨별 타일 그리드가 어긋날 수 있음.
- **구현 1 – API 확장**
  - 타일 서버 `get_slide_info()`에서 `levelDimensions` 추가: 각 OpenSlide 레벨의 `[width, height]` 배열. `/info` 응답에 포함.
  - 프론트 `SlideInfo`에 `levelDimensions?: [number, number][]` 추가.
- **구현 2 – 타일 소스 width/height를 최소 레벨 기준으로 계산 (되돌림됨)**
  - `levelDimensions`가 있으면 `osdWidth = minLevelWidth * 2^maxLevel`, `osdHeight = minLevelHeight * 2^maxLevel`로 계산해 OSD 타일 소스의 `width`/`height`로 사용.
  - 의도: OSD 레벨 0 타일 그리드가 서버 최소 레벨과 일치하도록.
  - **결과:** 줌 위치가 완전히 틀어짐. OSD content 크기와 오버레이/배율 표시에 쓰는 `slideInfo.width/height`(원본 픽셀)가 달라져 좌표계 불일치 발생.
  - **조치:** 타일 소스는 다시 **항상 `slideInfo.width`, `slideInfo.height`**만 사용하도록 되돌림. `levelDimensions`는 API·타입에만 남겨 두고, 타일 그리드 계산에는 사용하지 않음.
- **관련 파일:** `tile-server/app/tile_service.py` (levelDimensions 반환), `src/api/fetchSlideInfo.ts` (SlideInfo 타입), `src/components/WSIViewer.tsx` (width/height는 slideInfo만 사용하도록 복구).

**13.5 변경 요약 표**

| 구분 | 변경 내용 | 상태 |
|------|-----------|------|
| 뷰포트 동기화 | getBounds + viewportToImageRectangle, getCenter(true), viewportToImageZoom | 적용 유지 |
| UI | 상단 배율·중심 좌표 표시 | 적용 유지 |
| 줌 기준점 | zoomToRefPoint: false → canvas-scroll에서 getCenter(true)로 zoomBy | 우상단 기준 등 여전히 어긋남, **미해결** |
| 타일 정렬 | levelDimensions API 추가 | 적용 유지 |
| 타일 정렬 | osdWidth/osdHeight로 타일 소스 크기 변경 | **되돌림** (줌/좌표계 꼬임) |

**13.6 내일 검토 시 참고할 점**

- 줌 기준점: OSD 내부에서 “뷰포트 중심”이 어떤 좌표로 계산되는지, 커스텀 타일 소스·오버레이 레이아웃이 어떻게 반영되는지 추적 필요.
- 타일 레벨 정렬: OSD content 크기(width/height)를 바꾸지 않고, **레벨별 스케일/타일 개수만** OpenSlide 실제 크기에 맞추는 방식(예: getLevelScale 오버라이드 등)이 있는지 OSD 쪽 문서·소스 확인 필요.

---

##### 14. 타일 요청 계산과 레벨 크기 (OSD vs OpenSlide vs 우리 코드)

레벨이 바뀔 때 타일 위치가 어긋날 수 있다고 한 내용을, **공식/소스 기준으로** 어떻게 계산되는지 정리한다. 테스트는 SVS 파일로 하고 있음.

**14.1 OpenSeaDragon이 타일을 어떻게 계산하는지**

OSD는 기본 TileSource에서 **2의 거듭제곱 피라미드**를 가정한다. (소스: `openseadragon.js` 내 `$.TileSource`)

- **dimensions:** 타일 소스에 넘긴 `width`, `height`. **최대 해상도(가장 높은 레벨)에서의 이미지 크기**로 해석된다.
- **getLevelScale(level):**  
  `levelScaleCache[level] = 1 / Math.pow(2, this.maxLevel - level)`  
  즉 **레벨 L에서의 스케일 = 1 / 2^(maxLevel - L)**.  
  레벨 0이 가장 작고, maxLevel이 가장 크다.
- **레벨 L에서의 이미지 크기 (OSD 가정):**  
  `dimensions * getLevelScale(level)`  
  = **(width / 2^(maxLevel - L), height / 2^(maxLevel - L))**  
  따라서 **레벨 0 크기 = (width / 2^maxLevel, height / 2^maxLevel)**.
- **getNumTiles(level):**  
  `scale = getLevelScale(level)`  
  `numX = Math.ceil(scale * dimensions.x / getTileWidth(level))`  
  `numY = Math.ceil(scale * dimensions.y / getTileHeight(level))`  
  즉 레벨 L에서의 픽셀 크기를 타일 크기로 나눈 것을 올림한 값이 타일 개수.
- **타일 (x, y)가 커버하는 영역 (getTileBounds):**  
  레벨 L에서 픽셀 좌표:  
  `px = (x === 0) ? 0 : tileWidth * x - tileOverlap`  
  `py = (y === 0) ? 0 : tileHeight * y - tileOverlap`  
  (tileOverlap은 우리가 0으로 둠.)  
  즉 타일 (x, y)는 해당 레벨에서 **[x * tileSize, y * tileSize] ~ [(x+1)*tileSize, (y+1)*tileSize]** 픽셀 구간을 가리킨다.

**정리:** OSD는 **레벨 L 크기 = (width/2^(maxLevel-L), height/2^(maxLevel-L))** 로 고정하고, 그 크기 위에 tileSize로 나눠서 타일 (x,y)와 픽셀 영역을 계산한다. 공식 문서에도 “N layers where 2^(N+1) ≥ longest side” 같은 피라미드 설명이 있다.

**14.2 OpenSlide / SVS에서 레벨 크기가 어떻게 주어지는지**

- **OpenSlide Python 문서:**  
  - `level_dimensions[k]`: 레벨 k의 (width, height). **레벨 0이 최고 해상도.**  
  - `level_downsamples[k]`: 레벨 k의 다운샘플 배율 (**float**).  
  - **문서에는 “레벨이 정확히 2배수”라는 말이 없다.** 포맷/벤더에 따라 다르다고 보는 게 맞다.
- **Aperio SVS:**  
  - OpenSlide 문서·Aperio 포맷 설명: 첫 이미지가 풀 해상도, 그 다음 썸네일, 그 다음 **중간 피라미드 이미지들**이 있다고만 되어 있음.  
  - 실제 예시에서는 **4:1 다운샘플** 같은 비율이 나오는 경우도 있음 (2:1이 아닐 수 있음).  
  - 즉 **SVS의 level_dimensions는 스캐너/생성 도구마다 다르고, 2^(maxLevel-L) 공식과 일치한다는 보장이 없다.**

**14.3 우리 코드에서의 흐름**

| 단계 | 위치 | 동작 |
|------|------|------|
| 1 | WSIViewer | OSD 타일 소스에 `width = slideInfo.width`, `height = slideInfo.height`, `maxLevel = levelCount - 1` 전달. (OpenSlide 레벨 0 = 최고 해상도 = OSD의 maxLevel.) |
| 2 | OSD 내부 | 레벨 L 요청 시 `getLevelScale(L) = 1/2^(maxLevel-L)` 로 크기 계산 → `getNumTiles(L)` 로 (x,y) 개수 결정 → 필요한 (level, x, y)마다 `getTileUrl(level, x, y)` 호출. |
| 3 | getTileUrl | `serverLevel = maxLevel - level`. OSD 레벨 0 → 서버 레벨 (levelCount-1), OSD maxLevel → 서버 레벨 0. URL: `/tiles/{serverLevel}/{x}_{y}.jpg`. |
| 4 | 타일 서버 get_tile_bytes | OpenSlide `level_dimensions[level]`으로 해당 레벨의 (wL, hL) 사용. 타일 (x,y) → 해당 레벨 픽셀 (x*TILE_SIZE, y*TILE_SIZE). 이를 level 0 좌표로 변환: scale = (w0/wL, h0/hL), `read_region((px, py), level, (read_w, read_h))` 호출. |

**불일치 가능 지점:**  
- OSD가 **레벨 L 크기 = (width/2^(maxLevel-L), height/2^(maxLevel-L))** 로 가정해서 (x,y) 개수와 타일 영역을 정함.  
- 서버는 **실제 OpenSlide level_dimensions[serverLevel]** 로 같은 (x,y)에 대해 픽셀 영역을 잡음.  
- SVS에서 레벨별 크기가 2배수가 아니면, **같은 (x,y)라도 OSD가 생각하는 영역과 서버가 읽는 영역이 달라져** 레벨을 바꿀 때 타일이 어긋나 보일 수 있다.

**14.4 실제 SVS로 확인하는 방법**

1. **서버 `/info` 호출**  
   응답에 `levelDimensions`가 있으므로, 각 레벨의 실제 (width, height)를 확인할 수 있다.
2. **OSD 가정과 비교**  
   - `w0 = levelDimensions[0][0]`, `h0 = levelDimensions[0][1]`  
   - maxLevel = levelCount - 1  
   - OSD가 가정하는 레벨 L 크기: `(w0 / 2^(maxLevel - L), h0 / 2^(maxLevel - L))`  
   - 실제: `levelDimensions[L][0]`, `levelDimensions[L][1]`  
   - L을 0부터 maxLevel까지 돌려서 두 값이 일치하는지 비교하면, 현재 SVS가 2배수 피라미드인지 바로 확인 가능.
3. **level_downsamples (선택)**  
   OpenSlide에는 `level_downsamples[k]`도 있다. 필요하면 타일 서버 `/info`에 이 값을 추가해 두면, “레벨 간 배율”이 2가 아닌 경우를 숫자로 확인하기 좋다.

**14.5 요약**

- **OSD:** 타일 요청은 **항상** “레벨 L 크기 = (width/2^(maxLevel-L), height/2^(maxLevel-L))” 로 계산되며, 이건 **공식/소스에 명시된 2의 거듭제곱 가정**이다.
- **OpenSlide/SVS:** `level_dimensions`는 **포맷/벤더 의존**이며, **2배수라는 보장이 없다.** SVS 예시에서는 4:1 등 다른 비율도 나온다.
- **우리 코드:** OSD에는 (w0, h0)과 levelCount만 넘기고, 서버는 OpenSlide 실제 레벨 크기를 쓰므로, **SVS가 2배수가 아니면 레벨 경계에서 타일 위치가 어긋날 수 있다.**  
- 검증: `/info`의 `levelDimensions`와 위 OSD 가정 공식으로 레벨별 크기를 비교해 보면 된다.

**14.6 슬라이드 info 기반 동적 조정 (구현)**

- **방식:** `/info`의 `levelDimensions`가 있으면 타일 소스 옵션에 **`getLevelScale(level)`** 를 넘긴다. OSD는 이 함수가 있으면 `$.extend`로 인스턴스에 복사해 쓰므로, 기본 2^n 대신 **실제 레벨 크기 비율**을 쓰게 된다.
- **계산:** OSD 레벨 L ↔ 서버 레벨 `serverLevel = maxLevel - L`.  
  `getLevelScale(L) = levelDimensions[serverLevel][0] / width`  
  그러면 `getNumTiles(L)`이 `scale * dimensions / tileSize`로 계산할 때, 서버의 실제 레벨 크기와 타일 개수가 맞는다.
- **width/height:** 그대로 `slideInfo.width`, `slideInfo.height`만 사용한다. 뷰포트·오버레이 좌표계는 바꾸지 않아 줌/배율 표시는 그대로다.
- **관련 파일:** `src/components/WSIViewer.tsx` (tileSource에 `levelDims` 있을 때만 `getLevelScale` 추가).
